{"version":3,"sources":["logo.svg","pathfinder/node.jsx","algorithms/dijkstra.js","pathfinder/pathfinder.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","row","column","isStart","isFinish","isWall","onMouseDown","onMouseUp","onMouseEnter","type","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","col","filter","neighbor","getUnvisitedNeighbors","previousNode","Pathfinder","state","mouseIsPressed","createGrid","setState","newGrid","getNewGridWithWallToggled","i","setTimeout","document","getElementById","animateDijkstra","onClick","visualizeDijkstra","map","rowIndex","nodeIndex","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.c4134dad.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","import React, { Component } from \"react\";\n\nimport \"./node.css\";\n\nclass Node extends Component {\n\trender() {\n\t\tconst { row, column, isStart, isFinish, isWall, onMouseDown, onMouseUp, onMouseEnter } = this.props;\n\t\tconst type = isStart ? \" node-start\" : isFinish ? \" node-finish\" : isWall ? \" node-wall\" : \"\";\n\n\t\treturn (\n\t\t\t<div\n\t\t\t\tid={`node-${row}-${column}`}\n\t\t\t\tclassName={`node${type}`}\n\t\t\t\tonMouseDown={() => onMouseDown(row, column)}\n\t\t\t\tonMouseEnter={() => onMouseEnter(row, column)}\n\t\t\t\tonMouseUp={() => onMouseUp()}\n\t\t\t/>\n\t\t);\n\t}\n}\n\nexport default Node;\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n\tconst visitedNodesInOrder = [];\n\tstartNode.distance = 0;\n\tconst unvisitedNodes = getAllNodes(grid);\n\twhile (!!unvisitedNodes.length) {\n\t\tsortNodesByDistance(unvisitedNodes);\n\t\tconst closestNode = unvisitedNodes.shift();\n\t\t// If we encounter a wall, we skip it.\n\t\tif (closestNode.isWall) continue;\n\t\t// If the closest node is at a distance of infinity,\n\t\t// we must be trapped and should therefore stop.\n\t\tif (closestNode.distance === Infinity) return visitedNodesInOrder;\n\t\tclosestNode.isVisited = true;\n\t\tvisitedNodesInOrder.push(closestNode);\n\t\tif (closestNode === finishNode) return visitedNodesInOrder;\n\t\tupdateUnvisitedNeighbors(closestNode, grid);\n\t}\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n\tunvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n\tconst unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\tfor (const neighbor of unvisitedNeighbors) {\n\t\tneighbor.distance = node.distance + 1;\n\t\tneighbor.previousNode = node;\n\t}\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n\tconst neighbors = [];\n\tconst { col, row } = node;\n\tif (row > 0) neighbors.push(grid[row - 1][col]);\n\tif (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n\tif (col > 0) neighbors.push(grid[row][col - 1]);\n\tif (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n\treturn neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n\tconst nodes = [];\n\tfor (const row of grid) {\n\t\tfor (const node of row) {\n\t\t\tnodes.push(node);\n\t\t}\n\t}\n\treturn nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\n// export function getNodesInShortestPathOrder(finishNode) {\n// \tconst nodesInShortestPathOrder = [];\n// \tlet currentNode = finishNode;\n// \twhile (currentNode !== null) {\n// \t\tnodesInShortestPathOrder.unshift(currentNode);\n// \t\tcurrentNode = currentNode.previousNode;\n// \t}\n// \treturn nodesInShortestPathOrder;\n// }\n","import React, { Component } from \"react\";\nimport Node from \"./node\";\nimport { dijkstra, getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\n\nimport \"./pathfinder.css\";\n\nconst START_NODE_ROW = 25;\nconst START_NODE_COLUMN = 10;\nconst FINISH_NODE_ROW = 25;\nconst FINISH_NODE_COLUMN = 40;\n\nclass Pathfinder extends Component {\n\tstate = {\n\t\tgrid: [],\n\t\tmouseIsPressed: false,\n\t};\n\n\tcomponentDidMount() {\n\t\tconst grid = createGrid();\n\t\tthis.setState({ grid });\n\t}\n\n\thandleMouseDown(row, column) {\n\t\tconst newGrid = getNewGridWithWallToggled(this.state.grid, row, column);\n\t\tthis.setState({ grid: newGrid, mouseIsPressed: true });\n\t}\n\n\thandleMouseEnter(row, column) {\n\t\tif (this.state.mouseIsPressed) {\n\t\t\tconst newGrid = getNewGridWithWallToggled(this.state.grid, row, column);\n\t\t\tthis.setState({ grid: newGrid });\n\t\t}\n\t}\n\n\thandleMouseUp() {\n\t\tthis.setState({ mouseIsPressed: false });\n\t}\n\n\tanimateDijkstra(visitedNodesInOrder) {\n\t\tfor (let i = 0; i <= visitedNodesInOrder.length; i++) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst node = visitedNodesInOrder[i];\n\t\t\t\tdocument.getElementById(`node-${node.row}-${node.column}`).className = \"node node-visited\";\n\t\t\t}, 10 * i);\n\t\t}\n\t}\n\n\tvisualizeDijkstra() {\n\t\tconst { grid } = this.state;\n\t\tconst startNode = grid[START_NODE_ROW][START_NODE_COLUMN];\n\t\tconst finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COLUMN];\n\t\tconst visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n\t\tthis.animateDijkstra(visitedNodesInOrder);\n\t}\n\n\trender() {\n\t\tconst { grid, mouseIsPressed } = this.state;\n\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<button onClick={() => this.visualizeDijkstra()}>Visualize Dijkstra's Algorithm</button>\n\t\t\t\t<div className=\"grid\">\n\t\t\t\t\t{grid.map((row, rowIndex) => {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<div key={rowIndex}>\n\t\t\t\t\t\t\t\t{row.map((node, nodeIndex) => {\n\t\t\t\t\t\t\t\t\tconst { row, column, isStart, isFinish, isWall } = node;\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t<Node\n\t\t\t\t\t\t\t\t\t\t\tkey={nodeIndex}\n\t\t\t\t\t\t\t\t\t\t\trow={row}\n\t\t\t\t\t\t\t\t\t\t\tcolumn={column}\n\t\t\t\t\t\t\t\t\t\t\tisStart={isStart}\n\t\t\t\t\t\t\t\t\t\t\tisFinish={isFinish}\n\t\t\t\t\t\t\t\t\t\t\tisWall={isWall}\n\t\t\t\t\t\t\t\t\t\t\tmouseIsPressed={mouseIsPressed}\n\t\t\t\t\t\t\t\t\t\t\tonMouseDown={(row, column) => this.handleMouseDown(row, column)}\n\t\t\t\t\t\t\t\t\t\t\tonMouseEnter={(row, column) => this.handleMouseEnter(row, column)}\n\t\t\t\t\t\t\t\t\t\t\tonMouseUp={() => this.handleMouseUp()}\n\t\t\t\t\t\t\t\t\t\t></Node>\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t);\n\t\t\t\t\t})}\n\t\t\t\t</div>\n\t\t\t</>\n\t\t);\n\t}\n}\n\nconst createGrid = () => {\n\tconst grid = [];\n\tfor (let row = 0; row < 40; ++row) {\n\t\tconst currentRow = [];\n\t\tfor (let column = 0; column < 50; ++column) {\n\t\t\tcurrentRow.push(createNode(row, column));\n\t\t}\n\t\tgrid.push(currentRow);\n\t}\n\treturn grid;\n};\n\nconst createNode = (row, column) => {\n\treturn {\n\t\trow,\n\t\tcolumn,\n\t\tisStart: row === START_NODE_ROW && column === START_NODE_COLUMN,\n\t\tisFinish: row === FINISH_NODE_ROW && column === FINISH_NODE_COLUMN,\n\t\tisWall: false,\n\t};\n};\n\nconst getNewGridWithWallToggled = (grid, row, column) => {\n\tlet node = grid[row][column];\n\tnode = {\n\t\t...node,\n\t\tisWall: !node.isWall,\n\t};\n\tgrid[row][column] = node;\n\treturn grid;\n};\n\nexport default Pathfinder;\n","import logo from \"./logo.svg\";\nimport \"./App.css\";\nimport Pathfinder from \"./pathfinder/pathfinder\";\n\nfunction App() {\n\treturn (\n\t\t<div className=\"App\">\n\t\t\t<Pathfinder />\n\t\t</div>\n\t);\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<App />\n\t</React.StrictMode>,\n\tdocument.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}