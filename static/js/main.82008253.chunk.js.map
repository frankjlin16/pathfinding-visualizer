{"version":3,"sources":["logo.svg","pathfinder/node.jsx","algorithms/dijkstra.js","pathfinder/pathfinder.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","row","column","isStart","isFinish","isWall","onMouseDown","onMouseEnter","onMouseUp","type","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","Pathfinder","state","mouseDown","createGrid","setState","newGrid","toggleWall","visitedNodes","path","nodesInShortestPathOrder","currentNode","unshift","getPath","animateDijkstra","i","setTimeout","animatePath","document","getElementById","style","margin","onClick","visualizeDijkstra","map","rowIndex","nodeIndex","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.82008253.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","import React, { Component } from \"react\";\n\nimport \"./node.css\";\n\nclass Node extends Component {\n\trender() {\n\t\tconst { row, column, isStart, isFinish, isWall, onMouseDown, onMouseEnter, onMouseUp } = this.props;\n\t\tconst type = isStart ? \" node-start\" : isFinish ? \" node-finish\" : isWall ? \" node-wall\" : \"\";\n\t\treturn (\n\t\t\t<div\n\t\t\t\tid={`node-${row}-${column}`}\n\t\t\t\tclassName={`node${type}`}\n\t\t\t\tonMouseDown={() => onMouseDown(row, column)}\n\t\t\t\tonMouseEnter={() => onMouseEnter(row, column)}\n\t\t\t\tonMouseUp={() => onMouseUp()}\n\t\t\t></div>\n\t\t);\n\t}\n}\n\nexport default Node;\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n\tconst visitedNodesInOrder = [];\n\tstartNode.distance = 0;\n\tconst unvisitedNodes = getAllNodes(grid);\n\twhile (!!unvisitedNodes.length) {\n\t\tsortNodesByDistance(unvisitedNodes);\n\t\tconst closestNode = unvisitedNodes.shift();\n\t\t// If we encounter a wall, we skip it.\n\t\tif (closestNode.isWall) continue;\n\t\t// If the closest node is at a distance of infinity,\n\t\t// we must be trapped and should therefore stop.\n\t\tif (closestNode.distance === Infinity) return visitedNodesInOrder;\n\t\tclosestNode.isVisited = true;\n\t\tvisitedNodesInOrder.push(closestNode);\n\t\tif (closestNode === finishNode) return visitedNodesInOrder;\n\t\tupdateUnvisitedNeighbors(closestNode, grid);\n\t}\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n\tunvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n\tconst unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\tfor (const neighbor of unvisitedNeighbors) {\n\t\tneighbor.distance = node.distance + 1;\n\t\tneighbor.previousNode = node;\n\t}\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n\tconst neighbors = [];\n\tconst { column, row } = node;\n\tif (row > 0) neighbors.push(grid[row - 1][column]);\n\tif (row < grid.length - 1) neighbors.push(grid[row + 1][column]);\n\tif (column > 0) neighbors.push(grid[row][column - 1]);\n\tif (column < grid[0].length - 1) neighbors.push(grid[row][column + 1]);\n\treturn neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n\tconst nodes = [];\n\tfor (const row of grid) {\n\t\tfor (const node of row) {\n\t\t\tnodes.push(node);\n\t\t}\n\t}\n\treturn nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getPath(finishNode) {\n\tconst nodesInShortestPathOrder = [];\n\tlet currentNode = finishNode;\n\twhile (currentNode !== null) {\n\t\tnodesInShortestPathOrder.unshift(currentNode);\n\t\tcurrentNode = currentNode.previousNode;\n\t}\n\treturn nodesInShortestPathOrder;\n}\n","import React, { Component } from \"react\";\nimport Node from \"./node\";\nimport { dijkstra, getPath } from \"../algorithms/dijkstra\";\n\nimport \"./pathfinder.css\";\n\nconst START_NODE_ROW = 17;\nconst START_NODE_COLUMN = 10;\nconst FINISH_NODE_ROW = 17;\nconst FINISH_NODE_COLUMN = 34;\n\nclass Pathfinder extends Component {\n\tstate = {\n\t\tgrid: [],\n\t\tmouseDown: false,\n\t};\n\n\tcomponentDidMount() {\n\t\tconst grid = createGrid();\n\t\tthis.setState({ grid });\n\t}\n\n\thandleMouseDown(row, column) {\n\t\tconst newGrid = toggleWall(this.state.grid, row, column);\n\t\tthis.setState({ grid: newGrid, mouseDown: true });\n\t}\n\n\thandleMouseEnter(row, column) {\n\t\tif (this.state.mouseDown) {\n\t\t\tconst newGrid = toggleWall(this.state.grid, row, column);\n\t\t\tthis.setState({ grid: newGrid });\n\t\t}\n\t}\n\n\thandleMouseUp() {\n\t\tthis.setState({ mouseDown: false });\n\t}\n\n\tvisualizeDijkstra() {\n\t\tconst { grid } = this.state;\n\t\tconst startNode = grid[START_NODE_ROW][START_NODE_COLUMN];\n\t\tconst finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COLUMN];\n\t\tconst visitedNodes = dijkstra(grid, startNode, finishNode);\n\t\tconst path = getPath(finishNode);\n\t\tthis.animateDijkstra(visitedNodes, path);\n\t}\n\n\tanimateDijkstra(visitedNodes, path) {\n\t\tfor (let i = 0; i <= visitedNodes.length; ++i) {\n\t\t\tif (i === visitedNodes.length) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis.animatePath(path);\n\t\t\t\t}, 5 * i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst node = visitedNodes[i];\n\t\t\t\tif (document.getElementById(`node-${node.row}-${node.column}`).className === \"node\")\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.column}`).className = \"node node-visited\";\n\t\t\t}, 5 * i);\n\t\t}\n\t}\n\n\tanimatePath(path) {\n\t\tfor (let i = 0; i < path.length; ++i) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst node = path[i];\n\t\t\t\tif (document.getElementById(`node-${node.row}-${node.column}`).className === \"node node-visited\")\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.column}`).className = \"node node-path\";\n\t\t\t}, 50 * i);\n\t\t}\n\t}\n\n\trender() {\n\t\tconst { grid, mouseDown } = this.state;\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<div className=\"grid\">\n\t\t\t\t\t<button style={{ margin: \"30px\" }} onClick={() => this.visualizeDijkstra()}>\n\t\t\t\t\t\tVisualize Dijkstra's Algorithm\n\t\t\t\t\t</button>\n\t\t\t\t\t{grid.map((row, rowIndex) => {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<div key={rowIndex}>\n\t\t\t\t\t\t\t\t{row.map((node, nodeIndex) => {\n\t\t\t\t\t\t\t\t\tconst { row, column, isStart, isFinish, isWall } = node;\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t<Node\n\t\t\t\t\t\t\t\t\t\t\tkey={nodeIndex}\n\t\t\t\t\t\t\t\t\t\t\trow={row}\n\t\t\t\t\t\t\t\t\t\t\tcolumn={column}\n\t\t\t\t\t\t\t\t\t\t\tisStart={isStart}\n\t\t\t\t\t\t\t\t\t\t\tisFinish={isFinish}\n\t\t\t\t\t\t\t\t\t\t\tisWall={isWall}\n\t\t\t\t\t\t\t\t\t\t\tmouseDown={mouseDown}\n\t\t\t\t\t\t\t\t\t\t\tonMouseDown={(row, column) => this.handleMouseDown(row, column)}\n\t\t\t\t\t\t\t\t\t\t\tonMouseEnter={(row, column) => this.handleMouseEnter(row, column)}\n\t\t\t\t\t\t\t\t\t\t\tonMouseUp={() => this.handleMouseUp()}\n\t\t\t\t\t\t\t\t\t\t></Node>\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t);\n\t\t\t\t\t})}\n\t\t\t\t</div>\n\t\t\t</>\n\t\t);\n\t}\n}\n\nconst createGrid = () => {\n\tconst grid = [];\n\tfor (let row = 0; row < 35; ++row) {\n\t\tconst currentRow = [];\n\t\tfor (let column = 0; column < 45; ++column) {\n\t\t\tcurrentRow.push(createNode(row, column));\n\t\t}\n\t\tgrid.push(currentRow);\n\t}\n\treturn grid;\n};\n\nconst createNode = (row, column) => {\n\treturn {\n\t\trow,\n\t\tcolumn,\n\t\tisStart: row === START_NODE_ROW && column === START_NODE_COLUMN,\n\t\tisFinish: row === FINISH_NODE_ROW && column === FINISH_NODE_COLUMN,\n\t\tisWall: false,\n\t\tisVisited: false,\n\t\tdistance: Infinity,\n\t\tpreviousNode: null,\n\t};\n};\n\nconst toggleWall = (grid, row, column) => {\n\tlet node = grid[row][column];\n\tif (!node.isStart && !node.isFinish)\n\t\tnode = {\n\t\t\t...node,\n\t\t\tisWall: !node.isWall,\n\t\t};\n\tgrid[row][column] = node;\n\treturn grid;\n};\n\nexport default Pathfinder;\n","import logo from \"./logo.svg\";\nimport \"./App.css\";\nimport Pathfinder from \"./pathfinder/pathfinder\";\n\nfunction App() {\n\treturn (\n\t\t<div className=\"App\">\n\t\t\t<Pathfinder />\n\t\t</div>\n\t);\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<App />\n\t</React.StrictMode>,\n\tdocument.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}