{"version":3,"sources":["logo.svg","pathfinder/node.jsx","algorithms/dijkstra.js","pathfinder/pathfinder.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","row","column","isStart","isFinish","isWall","onMouseDown","onMouseUp","onMouseEnter","type","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","Pathfinder","state","mouseIsPressed","createGrid","setState","newGrid","getNewGridWithWallToggled","nodesInShortestPathOrder","i","setTimeout","animateShortestPath","document","getElementById","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","onClick","visualizeDijkstra","map","rowIndex","nodeIndex","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.cb62d4a0.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","import React, { Component } from \"react\";\n\nimport \"./node.css\";\n\nclass Node extends Component {\n\trender() {\n\t\tconst { row, column, isStart, isFinish, isWall, onMouseDown, onMouseUp, onMouseEnter } = this.props;\n\t\tconst type = isStart ? \" node-start\" : isFinish ? \" node-finish\" : isWall ? \" node-wall\" : \"\";\n\n\t\treturn (\n\t\t\t<div\n\t\t\t\tid={`node-${row}-${column}`}\n\t\t\t\tclassName={`node${type}`}\n\t\t\t\tonMouseDown={() => onMouseDown(row, column)}\n\t\t\t\tonMouseEnter={() => onMouseEnter(row, column)}\n\t\t\t\tonMouseUp={() => onMouseUp()}\n\t\t\t/>\n\t\t);\n\t}\n}\n\nexport default Node;\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n\tconst visitedNodesInOrder = [];\n\tstartNode.distance = 0;\n\tconst unvisitedNodes = getAllNodes(grid);\n\twhile (!!unvisitedNodes.length) {\n\t\tsortNodesByDistance(unvisitedNodes);\n\t\tconst closestNode = unvisitedNodes.shift();\n\t\t// If we encounter a wall, we skip it.\n\t\tif (closestNode.isWall) continue;\n\t\t// If the closest node is at a distance of infinity,\n\t\t// we must be trapped and should therefore stop.\n\t\tif (closestNode.distance === Infinity) return visitedNodesInOrder;\n\t\tclosestNode.isVisited = true;\n\t\tvisitedNodesInOrder.push(closestNode);\n\t\tif (closestNode === finishNode) return visitedNodesInOrder;\n\t\tupdateUnvisitedNeighbors(closestNode, grid);\n\t}\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n\tunvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n\tconst unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\tfor (const neighbor of unvisitedNeighbors) {\n\t\tneighbor.distance = node.distance + 1;\n\t\tneighbor.previousNode = node;\n\t}\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n\tconst neighbors = [];\n\tconst { column, row } = node;\n\tif (row > 0) neighbors.push(grid[row - 1][column]);\n\tif (row < grid.length - 1) neighbors.push(grid[row + 1][column]);\n\tif (column > 0) neighbors.push(grid[row][column - 1]);\n\tif (column < grid[0].length - 1) neighbors.push(grid[row][column + 1]);\n\treturn neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n\tconst nodes = [];\n\tfor (const row of grid) {\n\t\tfor (const node of row) {\n\t\t\tnodes.push(node);\n\t\t}\n\t}\n\treturn nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n\tconst nodesInShortestPathOrder = [];\n\tlet currentNode = finishNode;\n\twhile (currentNode !== null) {\n\t\tnodesInShortestPathOrder.unshift(currentNode);\n\t\tcurrentNode = currentNode.previousNode;\n\t}\n\treturn nodesInShortestPathOrder;\n}\n","import React, { Component } from \"react\";\nimport Node from \"./node\";\nimport { dijkstra, getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\n\nimport \"./pathfinder.css\";\n\nconst START_NODE_ROW = 25;\nconst START_NODE_COLUMN = 15;\nconst FINISH_NODE_ROW = 25;\nconst FINISH_NODE_COLUMN = 35;\n\nclass Pathfinder extends Component {\n\tstate = {\n\t\tgrid: [],\n\t\tmouseIsPressed: false,\n\t};\n\n\tcomponentDidMount() {\n\t\tconst grid = createGrid();\n\t\tthis.setState({ grid });\n\t}\n\n\thandleMouseDown(row, column) {\n\t\tconst newGrid = getNewGridWithWallToggled(this.state.grid, row, column);\n\t\tthis.setState({ grid: newGrid, mouseIsPressed: true });\n\t}\n\n\thandleMouseEnter(row, column) {\n\t\tif (this.state.mouseIsPressed) {\n\t\t\tconst newGrid = getNewGridWithWallToggled(this.state.grid, row, column);\n\t\t\tthis.setState({ grid: newGrid });\n\t\t}\n\t}\n\n\thandleMouseUp() {\n\t\tthis.setState({ mouseIsPressed: false });\n\t}\n\n\tanimateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n\t\tfor (let i = 0; i <= visitedNodesInOrder.length; i++) {\n\t\t\tif (i === visitedNodesInOrder.length) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis.animateShortestPath(nodesInShortestPathOrder);\n\t\t\t\t}, 5 * i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst node = visitedNodesInOrder[i];\n\t\t\t\tdocument.getElementById(`node-${node.row}-${node.column}`).className = \"node node-visited\";\n\t\t\t}, 5 * i);\n\t\t}\n\t}\n\n\tanimateShortestPath(nodesInShortestPathOrder) {\n\t\tfor (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst node = nodesInShortestPathOrder[i];\n\t\t\t\tdocument.getElementById(`node-${node.row}-${node.column}`).className = \"node node-shortest-path\";\n\t\t\t}, 50 * i);\n\t\t}\n\t}\n\n\tvisualizeDijkstra() {\n\t\tconst { grid } = this.state;\n\t\tconst startNode = grid[START_NODE_ROW][START_NODE_COLUMN];\n\t\tconst finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COLUMN];\n\t\tconst visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n\t\tconst nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n\t\tthis.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n\t}\n\n\trender() {\n\t\tconst { grid, mouseIsPressed } = this.state;\n\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<button onClick={() => this.visualizeDijkstra()}>Visualize Dijkstra's Algorithm</button>\n\t\t\t\t<div className=\"grid\">\n\t\t\t\t\t{grid.map((row, rowIndex) => {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<div key={rowIndex}>\n\t\t\t\t\t\t\t\t{row.map((node, nodeIndex) => {\n\t\t\t\t\t\t\t\t\tconst { row, column, isStart, isFinish, isWall } = node;\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t<Node\n\t\t\t\t\t\t\t\t\t\t\tkey={nodeIndex}\n\t\t\t\t\t\t\t\t\t\t\trow={row}\n\t\t\t\t\t\t\t\t\t\t\tcolumn={column}\n\t\t\t\t\t\t\t\t\t\t\tisStart={isStart}\n\t\t\t\t\t\t\t\t\t\t\tisFinish={isFinish}\n\t\t\t\t\t\t\t\t\t\t\tisWall={isWall}\n\t\t\t\t\t\t\t\t\t\t\tmouseIsPressed={mouseIsPressed}\n\t\t\t\t\t\t\t\t\t\t\tonMouseDown={(row, column) => this.handleMouseDown(row, column)}\n\t\t\t\t\t\t\t\t\t\t\tonMouseEnter={(row, column) => this.handleMouseEnter(row, column)}\n\t\t\t\t\t\t\t\t\t\t\tonMouseUp={() => this.handleMouseUp()}\n\t\t\t\t\t\t\t\t\t\t></Node>\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t);\n\t\t\t\t\t})}\n\t\t\t\t</div>\n\t\t\t</>\n\t\t);\n\t}\n}\n\nconst createGrid = () => {\n\tconst grid = [];\n\tfor (let row = 0; row < 40; ++row) {\n\t\tconst currentRow = [];\n\t\tfor (let column = 0; column < 50; ++column) {\n\t\t\tcurrentRow.push(createNode(row, column));\n\t\t}\n\t\tgrid.push(currentRow);\n\t}\n\treturn grid;\n};\n\nconst createNode = (row, column) => {\n\treturn {\n\t\trow,\n\t\tcolumn,\n\t\tisStart: row === START_NODE_ROW && column === START_NODE_COLUMN,\n\t\tisFinish: row === FINISH_NODE_ROW && column === FINISH_NODE_COLUMN,\n\t\tisWall: false,\n\t\tdistance: Infinity,\n\t\tisVisited: false,\n\t\tpreviousNode: null,\n\t};\n};\n\nconst getNewGridWithWallToggled = (grid, row, column) => {\n\tlet node = grid[row][column];\n\tnode = {\n\t\t...node,\n\t\tisWall: !node.isWall,\n\t};\n\tgrid[row][column] = node;\n\treturn grid;\n};\n\nexport default Pathfinder;\n","import logo from \"./logo.svg\";\nimport \"./App.css\";\nimport Pathfinder from \"./pathfinder/pathfinder\";\n\nfunction App() {\n\treturn (\n\t\t<div className=\"App\">\n\t\t\t<Pathfinder />\n\t\t</div>\n\t);\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<App />\n\t</React.StrictMode>,\n\tdocument.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}